<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs/data-structures on</title><link>https://wiki.yigit.run/tags/cs/data-structures/</link><description>Recent content in cs/data-structures on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wiki.yigit.run/tags/cs/data-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>Dijkstra's Algorithm</title><link>https://wiki.yigit.run/notes/Dijkstras-Algorithm/</link><pubDate>Mon, 24 Jan 2022 03:37:49 +0100</pubDate><guid>https://wiki.yigit.run/notes/Dijkstras-Algorithm/</guid><description>Dijkstra&amp;rsquo;s algorithm uses a [[notes/Greedy Method|Greedy Method]] design pattern to find the shortest path from a start vertice $s$ to an end vertice $e$ in a directed and weigthed [[notes/Graphs|graph]].</description></item><item><title>Directed Acyclic Graphs</title><link>https://wiki.yigit.run/notes/Directed-Acyclic-Graphs/</link><pubDate>Mon, 24 Jan 2022 03:13:19 +0100</pubDate><guid>https://wiki.yigit.run/notes/Directed-Acyclic-Graphs/</guid><description>There is a special name for directed [[notes/Graphs|Graphs]] without any cycles, directed acyclic graphs, or DAGs. For a DAG, there is an ordering of its vertices $v_1,v_2,&amp;hellip;v_n$ such that for any edge $(v_i,v_j)$, $i&amp;lt;j$.</description></item><item><title>Important Properties of a Graph</title><link>https://wiki.yigit.run/notes/Important-Properties-of-a-Graph/</link><pubDate>Sun, 23 Jan 2022 09:42:20 +0100</pubDate><guid>https://wiki.yigit.run/notes/Important-Properties-of-a-Graph/</guid><description>Let $G$ be a [[notes/Graphs|graph]] with $m$ edges in its edge set $E$ and $n$ vertices in its vertex set $V$:</description></item><item><title>Graph Terminology</title><link>https://wiki.yigit.run/notes/Graph-Terminology/</link><pubDate>Sun, 23 Jan 2022 09:34:06 +0100</pubDate><guid>https://wiki.yigit.run/notes/Graph-Terminology/</guid><description>Simple [[notes/Graphs|Graph]]: A graph with no [[notes/Vertice Terminology#^2fdf69|self loops]] Simple path: A path in which no vertex is visited more than once.</description></item><item><title>Vertice Terminology</title><link>https://wiki.yigit.run/notes/Vertice-Terminology/</link><pubDate>Sun, 23 Jan 2022 09:26:37 +0100</pubDate><guid>https://wiki.yigit.run/notes/Vertice-Terminology/</guid><description>A [[notes/Graphs|graph]] is made up of edges and vertices.
End Vertices: The vertices that are connected by an edge. Origin: First endpoint of vertice.</description></item><item><title>Graphs</title><link>https://wiki.yigit.run/notes/Graphs/</link><pubDate>Sun, 23 Jan 2022 09:19:27 +0100</pubDate><guid>https://wiki.yigit.run/notes/Graphs/</guid><description>Graphs are data-structures made up of nodes/vertices and edges. In a graph, vertices are connected to each other using edges. So, graphs can be represented using two sets, a set of edges and a set of vertices.</description></item><item><title>Adjacency Matrix</title><link>https://wiki.yigit.run/notes/Adjacency-Matrix/</link><pubDate>Sun, 23 Jan 2022 03:37:30 +0100</pubDate><guid>https://wiki.yigit.run/notes/Adjacency-Matrix/</guid><description>The adjacency matrix basically contains a matrix, in which each row and column is a vertice in the [[notes/Graphs|graph]] and every single cell in the matrix corresponds to a possible edge.</description></item><item><title>Adjacency Map</title><link>https://wiki.yigit.run/notes/Adjacency-Map/</link><pubDate>Sun, 23 Jan 2022 03:24:46 +0100</pubDate><guid>https://wiki.yigit.run/notes/Adjacency-Map/</guid><description>If an adjacency map, each vertice in the [[notes/Graphs|graph]] is mapped to a list of every [[notes/Vertice Terminology#^39dda4|incident]] edge. Similar to the [[notes/Edge List|Edge List]], it uses $O(n+m)$ space.</description></item><item><title>Edge List</title><link>https://wiki.yigit.run/notes/Edge-List/</link><pubDate>Sun, 23 Jan 2022 02:59:28 +0100</pubDate><guid>https://wiki.yigit.run/notes/Edge-List/</guid><description>The edge list structure basically holds a list of all the edges in a [[notes/Graphs|graph]] as well as a list of all the vertices.</description></item><item><title>Storing Graphs</title><link>https://wiki.yigit.run/notes/Storing-Graphs/</link><pubDate>Sun, 23 Jan 2022 02:57:15 +0100</pubDate><guid>https://wiki.yigit.run/notes/Storing-Graphs/</guid><description>There are three main ways of storing [[notes/Graphs|Graphs]] in your program:
[[notes/Edge List|Edge List]] [[notes/Adjacency Map|Adjacency Map]] [[notes/Adjacency Matrix|Adjacency Matrix]]</description></item><item><title>Red-Black Tree Deletion</title><link>https://wiki.yigit.run/notes/Red-Black-Tree-Deletion/</link><pubDate>Wed, 05 Jan 2022 08:43:21 +0300</pubDate><guid>https://wiki.yigit.run/notes/Red-Black-Tree-Deletion/</guid><description>After deleting from the [[notes/Red-Black Trees|Red-Black Trees]] just like a [[notes/Deleting From A Binary Search Tree|BST]], the promoted node is colored black.</description></item><item><title>Red-Black Tree Insertions</title><link>https://wiki.yigit.run/notes/Red-Black-Tree-Insertions/</link><pubDate>Wed, 05 Jan 2022 08:42:32 +0300</pubDate><guid>https://wiki.yigit.run/notes/Red-Black-Tree-Insertions/</guid><description>After inserting into a [[notes/Red-Black Trees|red black tree]] just like a [[notes/Binary Search Trees|BST]], the newly inserted node is colored red.</description></item><item><title>Red-Black Trees</title><link>https://wiki.yigit.run/notes/Red-Black-Trees/</link><pubDate>Tue, 04 Jan 2022 01:37:37 +0300</pubDate><guid>https://wiki.yigit.run/notes/Red-Black-Trees/</guid><description>Red-Black trees are a type of [[notes/Binary Search Trees|Binary Search Trees]] which aim to keep the tree balanced by adding an extra property into each node, whether it is red or black and enforcing a set of properties:</description></item><item><title>Multiway Search Trees</title><link>https://wiki.yigit.run/notes/Multiway-Search-Trees/</link><pubDate>Mon, 03 Jan 2022 12:44:50 +0300</pubDate><guid>https://wiki.yigit.run/notes/Multiway-Search-Trees/</guid><description>Multiway search trees are basically search trees, just like [[notes/Binary Search Trees|Binary Search Trees]] except that they don&amp;rsquo;t have to be binary trees and each node can have more than one entries.</description></item><item><title>(2,4) Trees</title><link>https://wiki.yigit.run/notes/24-Trees/</link><pubDate>Mon, 03 Jan 2022 01:01:08 +0300</pubDate><guid>https://wiki.yigit.run/notes/24-Trees/</guid><description>(2,4) trees are basically [[notes/Multiway Search Trees|Multiway Search Trees]] with two added rules:
Every internal node can have at most 4 children Every external node has the same depth In order to sustain this property, some checks and resutructuring often needs to be made in order to sustain this (2,4) tree property.</description></item><item><title>AVL Tree Operations</title><link>https://wiki.yigit.run/notes/AVL-Tree-Operations/</link><pubDate>Sun, 02 Jan 2022 10:46:07 +0300</pubDate><guid>https://wiki.yigit.run/notes/AVL-Tree-Operations/</guid><description>Insertion After inserting into an AVL Tree, which works just like a [[notes/Binary Tree|Binary Tree]], we insert the node into the tree, we traverse upwards from the inserted node, checking if the AVL property is broken at any point in the tree.</description></item><item><title>Binary Tree Restructuring</title><link>https://wiki.yigit.run/notes/Binary-Tree-Restructuring/</link><pubDate>Sun, 02 Jan 2022 10:33:43 +0300</pubDate><guid>https://wiki.yigit.run/notes/Binary-Tree-Restructuring/</guid><description>Sometimes, when creating a [[notes/Balanced Binary Search Trees|balanced tree]], [[notes/Binary Tree Rotations|rotations]] may not be sufficient. In this case, a technique called trinode structuring comes in, which is essentially one or two rotations combined.</description></item><item><title>AVL Trees</title><link>https://wiki.yigit.run/notes/AVL-Trees/</link><pubDate>Sun, 02 Jan 2022 10:30:38 +0300</pubDate><guid>https://wiki.yigit.run/notes/AVL-Trees/</guid><description>Keeping a [[notes/Binary Tree|Binary Tree]] [[notes/Balanced Binary Search Trees|balanced]] is crucial to sustain its performance, and AVLs trees ensure that by enforcing one simple rule to these trees:</description></item><item><title>Binary Tree Traversal</title><link>https://wiki.yigit.run/notes/Binary-Tree-Traversal/</link><pubDate>Sun, 02 Jan 2022 09:44:41 +0300</pubDate><guid>https://wiki.yigit.run/notes/Binary-Tree-Traversal/</guid><description>With recursion With recursion, it pretty straightforward, here is an example java code:
1 2 3 4 5 6 7 public static void traverse(BinaryTree t, List&amp;lt;Integer&amp;gt; l){ if(t == null) return; traverse(t.</description></item><item><title>Binary Tree Rotations</title><link>https://wiki.yigit.run/notes/Binary-Tree-Rotations/</link><pubDate>Sat, 01 Jan 2022 03:14:57 +0100</pubDate><guid>https://wiki.yigit.run/notes/Binary-Tree-Rotations/</guid><description>A rotation of a [[notes/Binary Tree|Binary Tree]] node is basically replacing a node with one of its children. In order to sustain the search tree property of a binary tree however, when replacing a node with its left child, the host becomes its right child, and the reverse applies when replacing wit its right child.</description></item><item><title>Balanced Binary Search Trees</title><link>https://wiki.yigit.run/notes/Balanced-Binary-Search-Trees/</link><pubDate>Sat, 01 Jan 2022 03:12:26 +0100</pubDate><guid>https://wiki.yigit.run/notes/Balanced-Binary-Search-Trees/</guid><description>How a [[notes/Binary Search Trees|BST]] performs depends largely on how well balanced it is. If a tree has mostly linear structure, then its worst-case time complexity for searching becomes $O(n)$ instead of $O(log(n))$.</description></item><item><title>Deleting From A Binary Search Tree</title><link>https://wiki.yigit.run/notes/Deleting-From-A-Binary-Search-Tree/</link><pubDate>Sat, 01 Jan 2022 03:08:29 +0100</pubDate><guid>https://wiki.yigit.run/notes/Deleting-From-A-Binary-Search-Tree/</guid><description>Deleting from a [[notes/Binary Search Trees|binary search tree]] can be a tricky process since we want to sustain the BST property of the tree upon deletion.</description></item><item><title>Binary Search Trees</title><link>https://wiki.yigit.run/notes/Binary-Search-Trees/</link><pubDate>Sat, 01 Jan 2022 02:37:16 +0100</pubDate><guid>https://wiki.yigit.run/notes/Binary-Search-Trees/</guid><description>Binary search trees are an extension of the [[notes/Binary Tree|Binary Tree]] data structure, except it has two extra constraint:
A node can have two children, the children with the value less than the node&amp;rsquo;s is placed to the left of it, and the one with a higher value is placed to the right.</description></item><item><title>Hash Tables</title><link>https://wiki.yigit.run/notes/Hash-Tables/</link><pubDate>Fri, 31 Dec 2021 12:57:08 +0300</pubDate><guid>https://wiki.yigit.run/notes/Hash-Tables/</guid><description>A hash table is a data structure in which every entry is mapped into an index in an [[notes/Array|Array]] according to that entry&amp;rsquo;s [[notes/Hash Functions|hash value]].</description></item><item><title>Maps</title><link>https://wiki.yigit.run/notes/Maps/</link><pubDate>Fri, 31 Dec 2021 12:31:40 +0300</pubDate><guid>https://wiki.yigit.run/notes/Maps/</guid><description>Maps are data structures like [[notes/Array|arrays]], they allow storing a set of elements in a single data structure and makes them accessible using keys instead if indexes.</description></item><item><title>Sets</title><link>https://wiki.yigit.run/notes/Sets/</link><pubDate>Fri, 31 Dec 2021 03:08:51 +0300</pubDate><guid>https://wiki.yigit.run/notes/Sets/</guid><description>Sets are data-structures similat to [[notes/Maps|Maps]], except that there is no key-value relationship. The difference of sets from [[notes/Array|Array]]s is that sets do not have indexes, and can only have one copy of a certain entry.</description></item><item><title>Binary Tree</title><link>https://wiki.yigit.run/notes/Binary-Tree/</link><pubDate>Tue, 14 Dec 2021 20:32:21 +0100</pubDate><guid>https://wiki.yigit.run/notes/Binary-Tree/</guid><description>A binary [[notes/Tree|Tree]] is a tree with a few extra constraints added on top:
Every node can have at most 2 children Each child node is either left or right child.</description></item><item><title>Down-Heap Bubbling</title><link>https://wiki.yigit.run/notes/Down-Heap-Bubbling/</link><pubDate>Tue, 14 Dec 2021 20:32:21 +0100</pubDate><guid>https://wiki.yigit.run/notes/Down-Heap-Bubbling/</guid><description>Down-Heap bubbling is basically the reverse of [[notes/Up-Heap Bubbling|Heap Bubbling]], when the heap-order property of a heap is broken due to a node that is not a leaf, you need to apply down-heap bubbling.</description></item><item><title>Full vs Complete Binary Trees</title><link>https://wiki.yigit.run/notes/Full-Complete-Trees/</link><pubDate>Tue, 14 Dec 2021 20:32:21 +0100</pubDate><guid>https://wiki.yigit.run/notes/Full-Complete-Trees/</guid><description>In a full/complete [[notes/Binary Tree|Binary Tree]], every node has two children, except the leaf nodes. In a complete binary tree however, every level has the maximum number of nodes it can have.</description></item><item><title>Heap</title><link>https://wiki.yigit.run/notes/Heap/</link><pubDate>Tue, 14 Dec 2021 20:32:21 +0100</pubDate><guid>https://wiki.yigit.run/notes/Heap/</guid><description>A heap is basically a [[notes/Binary Tree|Binary Tree]] which is complete([[notes/Full &amp;amp; Complete Trees|Full vs Complete Binary Trees]]) and every child of a parent node ([[notes/Tree Terminology|Important Tree Terminology]]) has a value greater than or equal to the parent&amp;rsquo;s value.</description></item><item><title>Tree Representation with Arrays</title><link>https://wiki.yigit.run/notes/Tree-Representation-With-Arrays/</link><pubDate>Tue, 14 Dec 2021 20:32:21 +0100</pubDate><guid>https://wiki.yigit.run/notes/Tree-Representation-With-Arrays/</guid><description>It is very easy to represent [[notes/Tree|Tree]]s using a linked data structures, similar to [[notes/Linked List|Linked List]]. However, if you want more performance, it is sometimes better to use an [[notes/Array|Array]].</description></item><item><title>Dequeue</title><link>https://wiki.yigit.run/notes/Dequeue/</link><pubDate>Tue, 23 Nov 2021 09:00:33 +0100</pubDate><guid>https://wiki.yigit.run/notes/Dequeue/</guid><description>This is basically a [[notes/Queue|Queue]] data structure, except the user has access to both the head and the tail.</description></item><item><title>Queue</title><link>https://wiki.yigit.run/notes/Queue/</link><pubDate>Tue, 23 Nov 2021 09:00:33 +0100</pubDate><guid>https://wiki.yigit.run/notes/Queue/</guid><description>A queue is a first in first out data structure that the added data are lined up just like a queue.</description></item><item><title>Stack</title><link>https://wiki.yigit.run/notes/Stack/</link><pubDate>Tue, 23 Nov 2021 09:00:33 +0100</pubDate><guid>https://wiki.yigit.run/notes/Stack/</guid><description>A stack is a data structure that is organized like a stack of plates organized one top of each other. You only have access to the plate on top, you can peek at it, pop it off the stack or push a new plate on the stack.</description></item><item><title>Array</title><link>https://wiki.yigit.run/notes/Array/</link><pubDate>Tue, 16 Nov 2021 21:07:41 +0100</pubDate><guid>https://wiki.yigit.run/notes/Array/</guid><description>Arrays are data structures that allow access to its entries using indexes. They are basically an amount of space allocated in memory, and each entry in the array is placed in that space one after another.</description></item><item><title>Circularly Linked List</title><link>https://wiki.yigit.run/notes/Circularly-Linked-Lists/</link><pubDate>Tue, 16 Nov 2021 21:07:41 +0100</pubDate><guid>https://wiki.yigit.run/notes/Circularly-Linked-Lists/</guid><description>This is another type of specialized [[notes/Linked List|Linked List]]. Normally in a linked list, the tail node would have the next pointer set as null.</description></item><item><title>Doubly Linked List</title><link>https://wiki.yigit.run/notes/Doubly-Linked-List/</link><pubDate>Tue, 16 Nov 2021 21:07:41 +0100</pubDate><guid>https://wiki.yigit.run/notes/Doubly-Linked-List/</guid><description>Doubly linked list are very similar to [[notes/Linked List|Linked List]] except that instead of having one pointer at each node, which points to the next node, each node has two pointers: one pointing to the next node and the other pointing to the previous node.</description></item></channel></rss>