<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cs/sorting on</title><link>https://wiki.fr1nge.xyz/tags/cs/sorting/</link><description>Recent content in cs/sorting on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wiki.fr1nge.xyz/tags/cs/sorting/index.xml" rel="self" type="application/rss+xml"/><item><title>In-Place Merge-Sort</title><link>https://wiki.fr1nge.xyz/notes/In-Place-Merge-Sort/</link><pubDate>Thu, 30 Dec 2021 11:41:59 +0300</pubDate><guid>https://wiki.fr1nge.xyz/notes/In-Place-Merge-Sort/</guid><description>It is sometimes more efficient to implement [[/notes/Merge Sort|Merge Sort]] in-place. Here is an implementation that sorts an two-dimensional array of strings according to a column, the explanations are made as comments:</description></item><item><title>In-Place Quick Sort</title><link>https://wiki.fr1nge.xyz/notes/In-Place-Quick-Sort/</link><pubDate>Sat, 25 Dec 2021 02:40:50 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/In-Place-Quick-Sort/</guid><description>Implementing [[/notes/Quick Sort|Quick Sort]] in place allows us to decrease the space-complexity of the algorithm and make it slightly more efficient.</description></item><item><title>Radix Sort</title><link>https://wiki.fr1nge.xyz/notes/Radix-Sort/</link><pubDate>Fri, 24 Dec 2021 04:28:25 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Radix-Sort/</guid><description>Radix sort is a non-comparison based sorting algorithm, it allows us to do stable sorting in a fast manner for elements that are more complicated than integers.</description></item><item><title>Bucket Sort</title><link>https://wiki.fr1nge.xyz/notes/Bucket-Sort/</link><pubDate>Fri, 24 Dec 2021 04:18:32 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Bucket-Sort/</guid><description>Bucket sort is a non-comparison based sorting algorithm. It has the restriction that the integers in a list are in the range $[0, N]$.</description></item><item><title>Quick Sort</title><link>https://wiki.fr1nge.xyz/notes/Quick-Sort/</link><pubDate>Thu, 23 Dec 2021 12:52:48 +0300</pubDate><guid>https://wiki.fr1nge.xyz/notes/Quick-Sort/</guid><description>Quick sort is an algorithm that splits the array into three parts according to a pivot value, L, E, G, array with the elements that are less then, equal to, or greater than the pivot respectively.</description></item><item><title>Quick Sort Pivot Selection</title><link>https://wiki.fr1nge.xyz/notes/Quick-Sort-Pivot-Selection/</link><pubDate>Thu, 23 Dec 2021 01:05:53 +0300</pubDate><guid>https://wiki.fr1nge.xyz/notes/Quick-Sort-Pivot-Selection/</guid><description>The most important aspect in a quick sort algorithm is how the pivot is chosen, the pivot decides how well-balanced the recursion tree of the algorithm turns out to be.</description></item><item><title>Analysis of Merge Sort</title><link>https://wiki.fr1nge.xyz/notes/Analysis-of-Merge-Sort/</link><pubDate>Tue, 21 Dec 2021 08:35:42 +0300</pubDate><guid>https://wiki.fr1nge.xyz/notes/Analysis-of-Merge-Sort/</guid><description>Calculating the [[/notes/Big-Oh Notation|Big-Oh Complexity]] of [[/notes/Merge Sort|Merge Sort]] is not a difficult task. There are two ways to do it, one being more intuitive and the other being more mathematical.</description></item><item><title>Merging in Merge Sort</title><link>https://wiki.fr1nge.xyz/notes/Merging-in-Merge-Sort/</link><pubDate>Tue, 21 Dec 2021 07:59:57 +0300</pubDate><guid>https://wiki.fr1nge.xyz/notes/Merging-in-Merge-Sort/</guid><description>After the recursive calls return two sorted lists, you need to merge them. Since they are both sorted, merging them into a new sorted list can be done in $O(n)$ complexity.</description></item><item><title>Merge Sort</title><link>https://wiki.fr1nge.xyz/notes/Merge-Sort/</link><pubDate>Tue, 21 Dec 2021 04:05:02 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Merge-Sort/</guid><description>Merge sort is a sorting algorithm based on a divide and conquer approach. Basically in merge-sort, a list is halved and sorted and then the sorted parts are then [[/notes/Merging in Merge Sort|merged]].</description></item><item><title>Heap Sort</title><link>https://wiki.fr1nge.xyz/notes/Heap-Sort/</link><pubDate>Tue, 21 Dec 2021 02:54:31 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Heap-Sort/</guid><description>Heap sort is a faster version of [[/notes/Insertion Sort|Insertion Sort]], optimised by implementing a [[/notes/Heap|Heap]] into the [[/notes/Priority Queue|Priority Queue]] so that the insertion and removal stages take $O(nlog(n))$ time.</description></item><item><title>Insertion Sort on a Partially Sorted List</title><link>https://wiki.fr1nge.xyz/notes/Insertion-Sort-on-a-Partially-Sorted-List/</link><pubDate>Tue, 21 Dec 2021 02:14:06 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Insertion-Sort-on-a-Partially-Sorted-List/</guid><description>When you have a partially sorted list, you can change the definition of the [[/notes/Priority Queue|Priority Queue]] you use in [[/notes/Insertion Sort|Insertion Sort]] so that the new elements are first added to the end of the queue.</description></item><item><title>Insertion Sort</title><link>https://wiki.fr1nge.xyz/notes/Insertion-Sort/</link><pubDate>Tue, 21 Dec 2021 01:51:28 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Insertion-Sort/</guid><description>Insertion sort, is an algorithm based on [[/notes/Priority Queue|Priority Queue]]s. In insertion sort, you insert the elements that you want to sort into the priority queue in a sorted order.</description></item><item><title>Selection Sort</title><link>https://wiki.fr1nge.xyz/notes/Selection-Sort/</link><pubDate>Tue, 21 Dec 2021 01:45:34 +0100</pubDate><guid>https://wiki.fr1nge.xyz/notes/Selection-Sort/</guid><description>Selection sort is a sorting algorithm based on [[/notes/Priority Queue|Priority Queue]]s. In order to sort using selection sort, the items are inserted into a priority queue with their values as keys in the order they are currently at (i.</description></item></channel></rss>